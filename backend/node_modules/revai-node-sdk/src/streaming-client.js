"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RevAiStreamingClient = void 0;
const events_1 = require("events");
const stream_1 = require("stream");
const websocket_1 = require("websocket");
const BufferedDuplex_1 = require("./models/streaming/BufferedDuplex");
const RevAiApiDeploymentConfigConstants_1 = require("./models/RevAiApiDeploymentConfigConstants");
const sdkVersion = require('../package.json').version;
/**
 * Client which handles a streaming connection to the Rev AI API.
 * @event httpResponse emitted when the client fails to start a websocket connection and
 *      receives an http response. Event contains the http status code of the response.
 * @event connectFailed emitted when the client fails to begin a websocket connection and
 *      received a websocket error. Event contains the received error.
 * @event connect emitted when the client receives a connected message from the API. Contains
 *      the StreamingConnected returned from the API.
 * @event close emitted when the connection is properly closed by the server. Contains the
 *      close code and reason.
 * @event error emitted when an error occurs in the connection to the server. Contains the
 *      thrown error.
 */
class RevAiStreamingClient extends events_1.EventEmitter {
    /**
     * @param either string Access token used to validate API requests or RevAiApiClientConfig object
     * @param config Configuration of the audio the user will send from this client
     * @param version (optional) Version of the Rev AI API the user wants to use
     */
    constructor(params, config, version = 'v1') {
        super();
        this.apiClientConfig = {};
        if (typeof params === 'object') {
            this.apiClientConfig = Object.assign(this.apiClientConfig, params);
            if (this.apiClientConfig.version === null || this.apiClientConfig.version === undefined) {
                this.apiClientConfig.version = version;
            }
            if (this.apiClientConfig.deploymentConfig === null || this.apiClientConfig.deploymentConfig === undefined) {
                this.apiClientConfig.deploymentConfig = RevAiApiDeploymentConfigConstants_1.RevAiApiDeploymentConfigMap.get(RevAiApiDeploymentConfigConstants_1.RevAiApiDeployment.US);
            }
            if (this.apiClientConfig.token === null || this.apiClientConfig.token === undefined) {
                throw new Error('token must be defined');
            }
        }
        else {
            this.apiClientConfig.token = params;
            this.apiClientConfig.version = version;
            this.apiClientConfig.deploymentConfig = RevAiApiDeploymentConfigConstants_1.RevAiApiDeploymentConfigMap.get(RevAiApiDeploymentConfigConstants_1.RevAiApiDeployment.US);
        }
        this.apiClientConfig.serviceApi = 'speechtotext';
        this.streamsClosed = false;
        this.accessToken = this.apiClientConfig.token;
        this.config = config;
        this.baseUrl = `${this.apiClientConfig.deploymentConfig.baseWebsocketUrl}/${this.apiClientConfig.serviceApi}` +
            `/${this.apiClientConfig.version}/stream`;
        this.requests = new stream_1.PassThrough({ objectMode: true });
        this.responses = new stream_1.PassThrough({ objectMode: true });
        this.protocol = new BufferedDuplex_1.BufferedDuplex(this.requests, this.responses, {
            readableObjectMode: true,
            writableObjectMode: true
        });
        const clientConfig = {};
        const clientConfigExtensionProperties = {
            keepalive: true,
            keepaliveInterval: 30000
        };
        this.client = new websocket_1.client(Object.assign(Object.assign({}, clientConfig), clientConfigExtensionProperties));
        this.setUpHttpResponseHandler();
        this.setUpConnectionFailureHandler();
        this.setUpConnectedHandlers();
    }
    /**
     * Begins a streaming connection. Returns a duplex
     * from which the user can read responses from the api and to which the user
     * should write their audio data
     * @param config (Optional) Optional configuration for the streaming session
     *
     * @returns BufferedDuplex. Data written to this buffer will be sent to the api
     * Data received from the api can be read from this duplex
     */
    start(config) {
        let url = this.baseUrl +
            `?access_token=${this.accessToken}` +
            `&content_type=${this.config.getContentTypeString()}` +
            `&user_agent=${encodeURIComponent(`RevAi-NodeSDK/${sdkVersion}`)}`;
        if (config) {
            if (config.metadata) {
                url += `&metadata=${encodeURIComponent(config.metadata)}`;
            }
            if (config.customVocabularyID) {
                url += `&custom_vocabulary_id=${encodeURIComponent(config.customVocabularyID)}`;
            }
            if (config.filterProfanity) {
                url += '&filter_profanity=true';
            }
            if (config.removeDisfluencies) {
                url += '&remove_disfluencies=true';
            }
            if (config.deleteAfterSeconds !== null && config.deleteAfterSeconds !== undefined) {
                url += `&delete_after_seconds=${encodeURIComponent(config.deleteAfterSeconds.toString())}`;
            }
            if (config.detailedPartials) {
                url += '&detailed_partials=true';
            }
            if (config.startTs !== null && config.startTs !== undefined) {
                url += `&start_ts=${encodeURIComponent(config.startTs.toString())}`;
            }
            if (config.transcriber) {
                url += `&transcriber=${encodeURIComponent(config.transcriber)}`;
            }
            if (config.language) {
                url += `&language=${encodeURIComponent(config.language)}`;
            }
            if (config.skipPostprocessing) {
                url += '&skip_postprocessing=true';
            }
            if (config.enableSpeakerSwitch) {
                url += '&enable_speaker_switch=true';
            }
        }
        this.client.connect(url);
        return this.protocol;
    }
    /**
     * Signals to the api that you have finished sending data.
     */
    end() {
        this.protocol.end('EOS', 'utf8');
    }
    /**
     * Immediately kills the streaming connection, no more results will be returned from the API
     * after this is called.
     */
    unsafeEnd() {
        this.client.abort();
        this.closeStreams();
    }
    setUpHttpResponseHandler() {
        this.client.on('httpResponse', (response) => {
            this.emit('httpResponse', response.statusCode);
            this.closeStreams();
        });
    }
    setUpConnectionFailureHandler() {
        this.client.on('connectFailed', (error) => {
            this.emit('connectFailed', error);
            this.closeStreams();
        });
    }
    setUpConnectedHandlers() {
        this.client.on('connect', (conn) => {
            conn.on('error', (error) => {
                this.emit('error', error);
                this.closeStreams();
            });
            conn.on('close', (code, reason) => {
                this.emit('close', code, reason);
                this.closeStreams();
            });
            conn.on('message', (message) => {
                if (this.streamsClosed) {
                    return;
                }
                if (message.type === 'utf8') {
                    const response = JSON.parse(message.utf8Data);
                    if (response.type === 'connected') {
                        this.emit('connect', response);
                    }
                    else if (this.responses.writable) {
                        this.responses.write(response);
                    }
                }
            });
            this.doSendLoop(conn);
        });
    }
    doSendLoop(conn) {
        if (conn.connected) {
            const value = this.requests.read();
            if (value !== null) {
                if (typeof value === 'string') {
                    conn.sendUTF(value);
                }
                else {
                    conn.send(value);
                }
            }
            setTimeout(() => this.doSendLoop(conn), 100);
        }
    }
    closeStreams() {
        if (!this.streamsClosed) {
            this.streamsClosed = true;
            this.protocol.end();
            this.requests.end();
            this.responses.push(null);
        }
    }
}
exports.RevAiStreamingClient = RevAiStreamingClient;
//# sourceMappingURL=streaming-client.js.map