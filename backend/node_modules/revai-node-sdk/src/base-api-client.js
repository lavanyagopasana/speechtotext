"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseApiClient = void 0;
/* eslint-disable @typescript-eslint/ban-types */
const api_request_handler_1 = require("./api-request-handler");
const RevAiApiDeploymentConfigConstants_1 = require("./models/RevAiApiDeploymentConfigConstants");
/**
 * Base client implementation. Intended to be extended by a specific client per API
 */
class BaseApiClient {
    /**
     * @param either string Access token used to validate API requests or RevAiApiClientConfig object
     * @param serviceApi Type of api service
     * @param version (optional) version of the API to be used
     */
    constructor(params, serviceApi, version) {
        this.apiClientConfig = {};
        if (typeof params === 'object') {
            this.apiClientConfig = Object.assign(this.apiClientConfig, params);
            if (this.apiClientConfig.version === null || this.apiClientConfig.version === undefined) {
                this.apiClientConfig.version = version;
            }
            if (this.apiClientConfig.deploymentConfig === null || this.apiClientConfig.deploymentConfig === undefined) {
                this.apiClientConfig.deploymentConfig = RevAiApiDeploymentConfigConstants_1.RevAiApiDeploymentConfigMap.get(RevAiApiDeploymentConfigConstants_1.RevAiApiDeployment.US);
            }
            if (this.apiClientConfig.serviceApi === null || this.apiClientConfig.serviceApi === undefined) {
                this.apiClientConfig.serviceApi = serviceApi;
            }
            if (this.apiClientConfig.token === null || this.apiClientConfig.token === undefined) {
                throw new Error('token must be defined');
            }
        }
        else {
            this.apiClientConfig.token = params;
            this.apiClientConfig.version = version;
            this.apiClientConfig.deploymentConfig = RevAiApiDeploymentConfigConstants_1.RevAiApiDeploymentConfigMap.get(RevAiApiDeploymentConfigConstants_1.RevAiApiDeployment.US);
            this.apiClientConfig.serviceApi = serviceApi;
        }
        this.apiHandler = new api_request_handler_1.ApiRequestHandler(`${this.apiClientConfig.deploymentConfig.baseUrl}/${this.apiClientConfig.serviceApi}`
            + `/${this.apiClientConfig.version}/`, this.apiClientConfig.token);
    }
    /**
     * Get information about a specific job
     * @param id Id of job whose details are to be retrieved
     * @returns Job details
     */
    _getJobDetails(id) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiHandler.makeApiRequest('get', `/jobs/${id}`, {}, 'json');
        });
    }
    /**
     * Get a list of jobs submitted within the last 30 days in reverse chronological order
     * (last submitted first) up to the provided limit number of jobs per call. Pagination is supported via passing
     * the last job id from previous call into starting_after.
     * @param params Query params for this request
     * @returns List of job details
     */
    _getListOfJobs(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const query = this.buildQueryParams(params || {});
            return yield this.apiHandler.makeApiRequest('get', `/jobs${query ? `?${query}` : ''}`, {}, 'json');
        });
    }
    /**
     * Delete a specific job.
     * All data related to the job will be permanently deleted.
     * A job can only by deleted once it's completed.
     * @param id Id of job to be deleted
     */
    _deleteJob(id) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.apiHandler.makeApiRequest('delete', `/jobs/${id}`, {}, 'text');
        });
    }
    /**
     * Submit a job to the api.
     * @param options (optional) Options submitted with the job
     * @returns Details of the submitted job
     */
    _submitJob(options) {
        return __awaiter(this, void 0, void 0, function* () {
            options = this.filterNullOptions(options || {});
            return yield this.apiHandler.makeApiRequest('post', '/jobs', { 'Content-Type': 'application/json' }, 'json', options);
        });
    }
    /**
     * Get the result of a job.
     * @param id id of job to get result of
     * @param options (optional) Options submitted with the request
     * @param headers (optional) Http headers to be used for the request
     * @returns Job result object
     */
    _getResult(id, options, headers) {
        return __awaiter(this, void 0, void 0, function* () {
            options = this.filterNullOptions(options || {});
            const query = this.buildQueryParams(options || {});
            return yield this.apiHandler.makeApiRequest('get', `/jobs/${id}/result${query ? `?${query}` : ''}`, headers || {}, 'json');
        });
    }
    buildQueryParams(params) {
        return Object.keys(params).map((key) => `${key}=${params[key]}`).join('&');
    }
    filterNullOptions(options) {
        const filteredOptions = {};
        Object.keys(options).forEach((option) => {
            if (options[option] !== null && options[option] !== undefined) {
                filteredOptions[option] = options[option];
            }
        });
        return filteredOptions;
    }
}
exports.BaseApiClient = BaseApiClient;
//# sourceMappingURL=base-api-client.js.map